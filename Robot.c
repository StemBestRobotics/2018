#pragma config(Sensor, dgtl1,  motorJumper,    sensorTouch)
#pragma config(Sensor, dgtl2,  telescopeMax,   sensorTouch)
#pragma config(Sensor, dgtl3,  telescopeMin,   sensorTouch)
#pragma config(Motor,  port2,           driveMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           armRotateMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           armAngleMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armTelescopeMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           clawRotateServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           clawAngleServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           clawGrabServo, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//------------------------------------------------------


/* Requirements
Robot Team Requirements for Arm:
-Motors: 3
-X-Axis of Joystick needs to rotate arm with motor
-Y-Axis of Joystick needs to angle arm with motor
-One Button needs to extend arm up to limit, while another retracts arm back to different limit, using same motor

Robot Team Requirements for claw:
Servos: 3
- button needs to toggle rotation of claw between 0 and 90 degrees with servo
- button needs to toggle angle of claw between 0 and 90 degrees with servo
- button needs to toggle opening and closing of claw with servo

Robot team Requirements for driving:
Motors: 1
- X-Axis of Joystick controls movement of robot with motor
- Needs deadband for extra precision
- Needs a way to toggle between inverted and normal controls

Robot Team Requirements for Speed:
No Motors or Servos
- A button needs to toggle motor speed between 100% and 50% for all motors

*/
//------------------------------------------------------
//VARIABLES:
bool clawGrabToggle = false; 														//A boolean, clawGrabToggle, that holds a value that determines the state that the claw-grabbing servo is in (open v closed)
bool clawGrabCheck = true;															//A boolean, clawGrabCheck, that holds a value that prevents the clawGrabToggle boolean from being toggled more than once per button press
bool speedToggleCheck = true;														//A boolean, speedToggleCheck, that holds a value that prevents the motorSpeed float from being changed more than once per button press
float motorSpeed = 1;																		//A float, motorSpeed, that holds the value of the multiplier for the speed of the motors
int deadband = 10;																			//An integer, deadband, that holds the value for the size of the deadbands
//------------------------------------------------------
void speedToggle(){																			//SPEED TOGGLE: allows button to toggle current motor speed between 100% speed and 50% speed
	if(vexRT[Btn8R] && speedToggleCheck){										//Checks if Button 8R is being pressed and boolean speedToggleCheck is true. If true, it goes to the next line
		speedToggleCheck=false;																//Sets boolean speedToggleCheck to false
		if(motorSpeed==1){																		//Checks if the motorSpeed multiplier is at 100%. If true, it goes to the next line.
			motorSpeed=0.5;																			//Sets motorSpeed multiplier to 50%
		}else{																								//If it was false, and the motorSpeed multiplier was not at 100%, it goes to the next line instead.
			motorSpeed=1;																				//Sets motorSpeed multiplier to 100%
		}																											//
	}else if(!vexRT[Btn8R]){																//If it was false and Button 8R is not being pressed, goes to next line
		speedToggleCheck=true;																//Sets motor speedToggleCheck to true.
	}
}
//------------------------------------------------------
void driveMotors(){																			//DRIVE: Allows for inversion and controlling of motors with joysticks
	if(SensorValue(motorJumper) == 1){											//JUMPER true: Checks for prescence of fused pin. If found:
		if (vexRT[Ch4] > deadband || vexRT[Ch4] < -deadband){		//DEADBAND true: Checks if Joystick values are outside of deadband, if they are:
			motor[driveMotor] = vexRT[Ch4]*motorSpeed; 							//NORMAL: Sets Motor value to be equivelent to joystick value. Joystick right: motor right, Joystick left: motor left
		}
		else {																									//DEADBAND false: Checks if Joystick values are outside of deadband, if they aren't:
			motor[driveMotor] = 0;																	//OFF: Sets motor value to 0, basically turns it off.
		}
	}else{																									//JUMPER false: Checks for prescense of fused pin. If not found:
		if (vexRT[Ch4] > deadband || vexRT[Ch4] < -deadband) {	//DEADBAND true: Checks if Joystick values are outside of deadband, if they are:
			motor[driveMotor] = -vexRT[Ch4]*motorSpeed; 						//INVERTED: Sets motor value to be opposite of joystick value. Joystick right: motor left, Joystick left: motor right
		}
		else {																									//DEADBAND false: Checks if Joystick values are outside of deadband. if they aren't:
			motor[driveMotor] = 0;																	//OFF: Sets motor value to 0, basically turns it off.
		}
	}
}
//------------------------------------------------------
void armMotors(){																				//ARM: ALlows Joystick and Buttons to control the movement of Arm
	motor[armRotateMotor] = vexRT[Ch1]*motorSpeed;					//ROTATE: assigns joystick to rotate arm
	motor[armAngleMotor] = vexRT[Ch2]*motorSpeed;						//ANGLE: assigns joystick to raise arm
	if(vexRT[Btn5U]){																				//TELESCOPE true: Checks if button 5U is being pressed, if it is:
		if(!SensorValue(telescopeMax)){													//LIMIT false: Checks if the telescopeMax limit switch has been hit, if it hasn't:
			motor[armTelescopeMotor] = 127*motorSpeed;							//Sets armTelescopeMotor to go forward, extending the arm
		}else{																									//LIMIT true: Checks if the telescpopeMax limit switch has been hit, if it has:
			motor[armTelescopeMotor] = 0;														//sets armTelescopeMotor to 0, preventing arm from extending
		}
	}else if(vexRT[Btn5D]){																	//TELESCOPE false, true: Checks if button 5U is being pressed, if it isn't, checks if button 5D is being presse, if it is:
		if(!SensorValue(telescopeMin)){													//LIMIT false: Checks if telescopeMin limit switch has been hit, if it hasn't:
			motor[armTelescopeMotor] = -127*motorSpeed;							//Sets armTelescopeMotor to go backward, retracting the arm
		}else{																									//LIMIT true: Checks if telescopeMin limit switch has been hit, if it has:
			motor[armTelescopeMotor] = 0;														//Sets armTelescopeMotor to 0, preventing the arm from retracting.
		}
	}else{																									//TELESCOPE false: Checks if button 5U is being pressed, if it isn't, checks if button 5D is being pressed, if neither are pressed:
		motor[armTelescopeMotor] = 0;														//OFF: sets armTelescopeMotor to 0, preventing the arm from retracting or extending.
	}
}
//------------------------------------------------------
void clawServos(){											 								//CLAW: Allows Controller to control movement of claw
 	if(vexRT[Btn6U]){																				//ANGLE CONTROL true: checks if button 6U is being pressed, if it is
		motor[clawAngleServo] = 127;														//sets the clawAngleServo to 127
	}else if(vexRT[Btn6D]){																	//ANGLE CONTROL false: checks if button 6U is being pressed, if it isn't:
		motor[clawAngleServo] = -127;														//sets the clawAngleServo to -127
 	}

 	if(vexRT[Btn7D] && clawGrabCheck){										//BUTTON true: Checks if button 7D is being pressed, and if clawGrabCheck is true, if they are both true:
		clawGrabCheck = false;																//sets clawGrabCheck to false, to prevent multiple toggles
		if(clawGrabToggle){																		//TOGGLE true: Checks if clawGrabToggle is true, if it is:
 			motor[clawGrabServo] = 101.6;													//sets the clawGrabServo to 90 degrees
 			clawGrabToggle = false;																//Toggles the clawGrabToggle boolean to false, so it can toggle from false to true next time
 		}else{																								//TOGGLE false: Checks if clawGrabToggle is true, if it isn't:
 			motor[clawGrabServo] = -127;													//sets the clawGrabServo to 0 degrees this time
			clawGrabToggle = true;																//Toggles the clawGrabToggle boolean to true, so it can toggle from true to false next time
		}
	}else if(!vexRT[Btn7D]){															//BUTTON false: Checks if button 7D is being pressed, if it isn't:
		clawGrabCheck = true;																	//sets clawGrabCheck to true, making sure that it can only be toggled again after the toggle button is released
 	}

 	if (vexRT[Btn8R]) {																		//BUTTON true: Checks if button 8R is being pressed, if it is:
 		motor[clawRotateServo] = 127;													//sets the clawRotateServo to 127
 	}
 	else if(vexRT[Btn8L]) {																//BUTTON false: checks if button 8R is being pressed, if it isn't, and button 8L is being pressed instead,
 		motor[clawRotateServo] = -127;												//sets the clawRotateServo to -127
 	}
}
//------------------------------------------------------
task main(){																						//main start task
	while(1==1) {																						//gurantees that the cortex will run the following methods indefinintly until it is turned off.
		speedToggle();																				//runs the speedToggle function
		driveMotors();																				//runs the driveMotors function
		armMotors();																					//runs the armMotors function
		clawServos();																					//runs the clawservos function
	}
}
